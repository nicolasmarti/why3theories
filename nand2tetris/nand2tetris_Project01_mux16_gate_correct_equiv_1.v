(* This file is generated by Why3's Coq 8.4 driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require bool.Bool.
Require int.Int.
Require int.Power.

(* Why3 assumption *)
Definition nand_gate (a:bool) (b:bool): bool := (negb (andb a b)).

(* Why3 assumption *)
Definition not_gate (a:bool): bool := (nand_gate a a).

Axiom not_gate_correct : forall (a:bool), ((not_gate a) = (negb a)).

(* Why3 assumption *)
Definition and_gate (a:bool) (b:bool): bool := (not_gate (nand_gate a b)).

Axiom and_gate_correct : forall (a:bool) (b:bool), ((and_gate a
  b) = (andb a b)).

(* Why3 assumption *)
Definition or_gate (a:bool) (b:bool): bool := let x := (nand_gate a a) in
  let y := (nand_gate b b) in (nand_gate x y).

Axiom or_gate_correct : forall (a:bool) (b:bool), ((or_gate a
  b) = (orb a b)).

(* Why3 assumption *)
Definition xor_gate (a:bool) (b:bool): bool := let x := (nand_gate a b) in
  let y := (nand_gate a x) in let z := (nand_gate b x) in (nand_gate y z).

Axiom xor_gate_correct : forall (a:bool) (b:bool), ((xor_gate a
  b) = (xorb a b)).

(* Why3 assumption *)
Definition muxb (a:bool) (b:bool) (sel:bool): bool :=
  match sel with
  | false => a
  | true => b
  end.

(* Why3 assumption *)
Definition mux_gate (a:bool) (b:bool) (sel:bool): bool := let nsel :=
  (not_gate sel) in let x := (nand_gate a nsel) in let y := (nand_gate b
  sel) in (nand_gate x y).

Axiom mux_gate_correct : forall (a:bool) (b:bool) (sel:bool), ((mux_gate a b
  sel) = (muxb a b sel)).

(* Why3 assumption *)
Definition dmuxb (in_:bool) (sel:bool): (bool* bool)%type :=
  match sel with
  | false => (in_, false)
  | true => (false, in_)
  end.

(* Why3 assumption *)
Definition dmux_gate (in_:bool) (sel:bool): (bool* bool)%type := let nsel :=
  (not_gate sel) in let x := (and_gate nsel in_) in let y := (and_gate sel
  in_) in (x, y).

Axiom dmux_gate_correct : forall (in_:bool) (sel:bool), ((dmux_gate in_
  sel) = (dmuxb in_ sel)).

Parameter infix_eqeq: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom refl : forall {a:Type} {a_WT:WhyType a}, forall (x:a), (infix_eqeq x
  x).

Axiom sym : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (y:a), (infix_eqeq
  x y) -> (infix_eqeq y x).

Axiom trans : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (y:a) (z:a),
  (infix_eqeq x y) -> ((infix_eqeq y z) -> (infix_eqeq x z)).

Axiom ext : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (y:a), (infix_eqeq
  x y) <-> (x = y).

Axiom size_lb : (0%Z < 16%Z)%Z.

Axiom bitv : Type.
Parameter bitv_WhyType : WhyType bitv.
Existing Instance bitv_WhyType.

Parameter mixfix_lbrb: bitv -> Z -> bool.

Parameter mixfix_lblsmnrb: bitv -> Z -> bool -> bitv.

Axiom bitv_eq : forall (b1:bitv) (b2:bitv), (forall (x:Z), ((0%Z <= x)%Z /\
  (x < 16%Z)%Z) -> ((mixfix_lbrb b1 x) = (mixfix_lbrb b2 x))) <-> (infix_eqeq
  b1 b2).

Axiom set_out_of_bound : forall (bv:bitv), forall (i:Z), forall (b:bool),
  ((i < 0%Z)%Z \/ (16%Z <= i)%Z) -> ((mixfix_lblsmnrb bv i b) = bv).

Axiom set_diff : forall (bv:bitv), forall (x1:Z) (x2:Z), forall (b1:bool)
  (b2:bool), (~ (x1 = x2)) -> ((mixfix_lblsmnrb (mixfix_lblsmnrb bv x1 b1) x2
  b2) = (mixfix_lblsmnrb (mixfix_lblsmnrb bv x2 b2) x1 b1)).

Axiom set_eq : forall (bv:bitv), forall (x1:Z) (x2:Z), forall (b1:bool)
  (b2:bool), (x1 = x2) -> ((mixfix_lblsmnrb (mixfix_lblsmnrb bv x1 b1) x2
  b2) = (mixfix_lblsmnrb bv x2 b2)).

Axiom lookup_set : forall (bv:bitv), forall (x1:Z) (x2:Z), forall (b:bool),
  (x1 = x2) -> (((0%Z <= x1)%Z /\ (x1 < 16%Z)%Z) ->
  ((mixfix_lbrb (mixfix_lblsmnrb bv x1 b) x2) = b)).

Parameter zeros: bitv.

Axiom zeros_get : forall (i:Z), ((0%Z <= i)%Z /\ (i < 16%Z)%Z) ->
  ((mixfix_lbrb zeros i) = false).

Parameter ones: bitv.

Axiom ones1 : forall (i:Z), ((0%Z <= i)%Z /\ (i < 16%Z)%Z) ->
  ((mixfix_lbrb ones i) = true).

Parameter all: bool -> bitv.

Axiom all1 : forall (b:bool), forall (i:Z), ((0%Z <= i)%Z /\ (i < 16%Z)%Z) ->
  ((mixfix_lbrb (all b) i) = b).

Parameter notbv: bitv -> bitv.

Axiom notbv_ax : forall (b:bitv), forall (x:Z), ((0%Z <= x)%Z /\
  (x < 16%Z)%Z) -> ((mixfix_lbrb (notbv b) x) = (negb (mixfix_lbrb b x))).

Parameter andbv: bitv -> bitv -> bitv.

Axiom andbv_ax : forall (b1:bitv) (b2:bitv), forall (x:Z), ((0%Z <= x)%Z /\
  (x < 16%Z)%Z) -> ((mixfix_lbrb (andbv b1 b2) x) = (andb (mixfix_lbrb b1
  x) (mixfix_lbrb b2 x))).

Parameter orbv: bitv -> bitv -> bitv.

Axiom orbv_ax : forall (b1:bitv) (b2:bitv), forall (x:Z), ((0%Z <= x)%Z /\
  (x < 16%Z)%Z) -> ((mixfix_lbrb (orbv b1 b2) x) = (orb (mixfix_lbrb b1
  x) (mixfix_lbrb b2 x))).

Parameter to_uint: bitv -> Z.

Axiom bit2uint_zeros : ((to_uint zeros) = 0%Z).

Axiom bit2uint_set : forall (b:bitv), forall (x:Z), ((0%Z <= x)%Z /\
  (x < 16%Z)%Z) -> (((mixfix_lbrb b x) = true) ->
  ((to_uint b) = ((to_uint (mixfix_lblsmnrb b x
  false)) + (int.Power.power 2%Z x))%Z)).

Parameter incr: bitv -> bitv.

Axiom incr_lwb : forall (b:bitv), ((mixfix_lbrb (incr b)
  0%Z) = (xorb (mixfix_lbrb b 0%Z) true)).

Axiom incr_nb : forall (b:bitv), forall (x:Z), ((0%Z < x)%Z /\
  (x < 16%Z)%Z) -> ((mixfix_lbrb (incr b) x) = (xorb (mixfix_lbrb b
  x) (andb (mixfix_lbrb b (x - 1%Z)%Z) (negb (mixfix_lbrb (incr b)
  (x - 1%Z)%Z))))).

Axiom incr_add_1 : forall (b:bitv), (~ (b = ones)) ->
  ((to_uint (incr b)) = ((to_uint b) + 1%Z)%Z).

Parameter weird: bitv.

Axiom weird_ax : ((mixfix_lbrb weird (16%Z - 1%Z)%Z) = true) /\ forall (x:Z),
  ((0%Z <= x)%Z /\ (x < (16%Z - 1%Z)%Z)%Z) -> ((mixfix_lbrb weird
  x) = false).

(* Why3 assumption *)
Definition two_complement (b:bitv): bitv := (incr (notbv b)).

Axiom two_complement_inv : forall (b:bitv),
  ((two_complement (two_complement b)) = b).

Parameter to_sint: bitv -> Z.

Axiom bit2sint_pos : forall (b:bitv), ((mixfix_lbrb b
  (16%Z - 1%Z)%Z) = false) -> ((to_sint b) = (to_uint b)).

Axiom bit2sint_neg : forall (b:bitv), (~ (b = weird)) -> (((mixfix_lbrb b
  (16%Z - 1%Z)%Z) = true) ->
  ((to_sint b) = (-(to_uint (two_complement b)))%Z)).

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter map: bitv -> bitv.

Axiom map_in_bound : forall (bv:bitv), forall (i:Z), ((0%Z <= i)%Z /\
  (i < 16%Z)%Z) -> ((mixfix_lbrb (map bv) i) = (not_gate (mixfix_lbrb bv
  i))).

Axiom not16_gate_correct_equiv : forall (a1:bitv), (infix_eqeq (map a1)
  (notbv a1)).

Axiom not16_gate_correct : forall (a1:bitv), ((map a1) = (notbv a1)).

Axiom a1 : Type.
Parameter a1_WhyType : WhyType a1.
Existing Instance a1_WhyType.

Parameter map2: bitv -> bitv -> bitv.

Axiom map_in_bound1 : forall (bv1:bitv) (bv2:bitv), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < 16%Z)%Z) -> ((mixfix_lbrb (map2 bv1 bv2)
  i) = (and_gate (mixfix_lbrb bv1 i) (mixfix_lbrb bv2 i))).

Axiom and16_gate_correct_equiv : forall (a2:bitv) (b:bitv), (infix_eqeq
  (map2 a2 b) (andbv a2 b)).

Axiom and16_gate_correct : forall (a2:bitv) (b:bitv), ((map2 a2
  b) = (andbv a2 b)).

Axiom a2 : Type.
Parameter a2_WhyType : WhyType a2.
Existing Instance a2_WhyType.

Parameter map21: bitv -> bitv -> bitv.

Axiom map_in_bound2 : forall (bv1:bitv) (bv2:bitv), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < 16%Z)%Z) -> ((mixfix_lbrb (map21 bv1 bv2)
  i) = (or_gate (mixfix_lbrb bv1 i) (mixfix_lbrb bv2 i))).

Axiom or16_gate_correct_equiv : forall (a3:bitv) (b:bitv), (infix_eqeq
  (map21 a3 b) (orbv a3 b)).

Axiom or16_gate_correct : forall (a3:bitv) (b:bitv), ((map21 a3 b) = (orbv a3
  b)).

(* Why3 assumption *)
Definition mux16b (a3:bitv) (b:bitv) (sel:bool): bitv :=
  match sel with
  | false => a3
  | true => b
  end.

Axiom a3 : Type.
Parameter a3_WhyType : WhyType a3.
Existing Instance a3_WhyType.

Parameter map3: bitv -> bitv -> bitv -> bitv.

Axiom map_in_bound3 : forall (bv1:bitv) (bv2:bitv) (bv3:bitv), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < 16%Z)%Z) -> ((mixfix_lbrb (map3 bv1 bv2 bv3)
  i) = (mux_gate (mixfix_lbrb bv1 i) (mixfix_lbrb bv2 i) (mixfix_lbrb bv3
  i))).

(* Why3 assumption *)
Definition mux16_gate (a4:bitv) (b:bitv) (sel:bool): bitv := (map3 a4 b
  (all sel)).

(* Why3 goal *)
Theorem mux16_gate_correct_equiv : forall (sel:bool), forall (a4:bitv)
  (b:bitv), (infix_eqeq (mux16_gate a4 b sel) (mux16b a4 b sel)).
(* Why3 intros sel a4 b. *)
intros sel a4 b.
rewrite <- bitv_eq.
intros.
unfold mux16_gate.
rewrite map_in_bound3.
unfold mux16b.
destruct sel.
rewrite mux_gate_correct.
unfold muxb.
rewrite all1.
auto.
auto.
rewrite mux_gate_correct.
unfold muxb.
rewrite all1.
auto.
auto.
auto.
Qed.


