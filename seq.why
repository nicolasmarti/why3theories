theory Seq

type wire = R | S | Q | NQ
type gate = G1 | G2

use import bool.Bool
use import map.Map
use import set.Set

type state = map wire bool

function nandb (b1 b2: bool): bool = notb (andb b1 b2)

function transition (g: gate) (st: state) : state
axiom transition_ax1: forall st: state.
      		      	     transition G1 st = st[Q <- nandb st[R] st[NQ]]
axiom transition_ax2: forall st: state.
      		      	     transition G2 st = st[NQ <- nandb st[S] st[Q]]

type gates = set gate
type wires = set wire


function output (g: gate) : wires
axiom output_ax1: output G1 = singleton Q
axiom output_ax2: output G2 = singleton NQ


function input (w: wire) : gates
axiom input_ax1: input S = singleton G2
axiom input_ax2: input NQ = singleton G1
axiom input_ax3: input R = singleton G1
axiom input_ax4: input Q = singleton G2

function inputs (ws: wires) : gates
axiom inputs_ax1: forall ws: wires.
      		  forall g: gate.
		    (exists w: wire. mem w ws /\ mem g (input w)) <-> mem g (inputs ws)


lemma inputs_empty: inputs empty == empty

predicate map_eq (m1 m2: map 'a 'b) = forall x: 'a. m1[x] = m2[x]

function changed_wires (st1 st2: state) : wires
axiom changed_wire_ax1: forall st1 st2: state.
      			       forall w: wire. st1[w] <> st2[w] <-> mem w (changed_wires st1 st2)

inductive semantics (st1 st2: state) (gs: gates) =
| stable: forall st1 st2: state. forall gs: gates.
  	     	    gs == empty ->
		    map_eq st1 st2 ->
		    semantics st1 st2 gs
| unstable: forall st1 st2: state. forall gs: gates.
  	    (forall g: gate. mem g gs ->
	    	    let st1' = transition g st1 in
		    semantics (transition g st1) st2 (union (diff gs (singleton g)) (inputs (changed_wires st1 st1')))
	    ) ->
	    semantics st1 st2 gs


constant null_state: state
axiom null_state: forall w: wire. null_state[w] = False

(**)

lemma L1_l1: let st1 = null_state[S <- True][Q <- True] in 
         let st1' = transition G1 st1 in
	 changed_wires st1 st1' == empty

lemma L1_l2: let st1 = null_state[S <- True][Q <- True] in 
         let st1' = transition G2 st1 in
	 changed_wires st1 st1' == empty

lemma L1_l3: semantics null_state[S <- True][Q <- True] null_state[S <- True][Q <- True] (singleton G1)

lemma L1_l4: semantics null_state[S <- True][Q <- True] null_state[S <- True][Q <- True] (singleton G2)

lemma L1_l5: semantics null_state[S <- True] null_state[S <- True][Q <- True] (add G1 (singleton G2))

(**)

lemma L2_l1: let st1 = null_state[R <- True][NQ <- True] in 
         let st1' = transition G1 st1 in
	 changed_wires st1 st1' == empty

lemma L2_l2: let st1 = null_state[R <- True][NQ <- True] in 
         let st1' = transition G2 st1 in
	 changed_wires st1 st1' == empty

lemma L2_l3: semantics null_state[R <- True][Q <- True] null_state[R <- True][NQ <- True] (singleton G1)

lemma L2_l4: semantics null_state[R <- True][Q <- True] null_state[R <- True][NQ <- True] (singleton G2)

lemma L2_l5: semantics null_state[R <- True] null_state[R <- True][NQ <- True] (add G1 (singleton G2))

(**)



end