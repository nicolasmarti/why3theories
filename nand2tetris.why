
theory Bit16


constant size16: int = 16

clone export prelude.BitV with constant size = size16

end

theory Bit16Map

use import Bit16
use import int.Int
use import bool.Bool

type a

function f bool : bool

function map bitv : bitv

axiom map_in_bound: forall bv: bitv. forall i: int. (0 <= i /\ i < size16) -> (map bv)[i] = f bv[i] 

end

theory Bit16Map2

use import Bit16
use import int.Int
use import bool.Bool

type a

function f bool bool : bool

function map2 bitv bitv: bitv

axiom map_in_bound: forall bv1 bv2: bitv. forall i: int. (0 <= i /\ i < size16) -> (map2 bv1 bv2)[i] = f bv1[i] bv2[i] 

end

theory Bit16Map3

use import Bit16
use import int.Int
use import bool.Bool

type a

function f bool bool bool: bool

function map3 bitv bitv bitv: bitv

axiom map_in_bound: forall bv1 bv2 bv3: bitv. forall i: int. (0 <= i /\ i < size16) -> (map3 bv1 bv2 bv3)[i] = f bv1[i] bv2[i] bv3[i] 

end

theory Bit8

constant size8: int = 8

clone export prelude.BitV with constant size = size8

end

theory Bit2

constant size2: int = 2

clone export prelude.BitV with constant size = size2

end

theory Bit3

constant size3: int = 3

clone export prelude.BitV with constant size = size3

end


theory Project01

use import Bool
use import bool.Bool
use import int.Int

(* first we have the nand_gate *)
function nand_gate(a b: bool) : bool = notb (andb a b)

(* and we build all the other gate with it, proving equivalence with classical boolean operators *)
function not_gate (a: bool) : bool = nand_gate a a
lemma not_gate_correct: forall a: bool. not_gate a = notb a

function and_gate (a b: bool) : bool = not_gate (nand_gate a b)
lemma and_gate_correct: forall a b: bool. and_gate a b = andb a b

function or_gate (a b: bool) : bool = 
	 let x = nand_gate a a in
	 let y = nand_gate b b in
	 nand_gate x y
lemma or_gate_correct: forall a b: bool. or_gate a b = orb a b

lemma or_gate_comm: forall a b: bool. or_gate a b = or_gate b a

lemma or_gate_assoc: forall a b c: bool. or_gate (or_gate a b) c = or_gate a (or_gate b c)

function xor_gate (a b: bool) : bool =
	 let x = nand_gate a b in
	 let y = nand_gate a x in
	 let z = nand_gate b x in
	 nand_gate y z
lemma xor_gate_correct: forall a b: bool. xor_gate a b = xorb a b

function muxb (a b sel: bool) : bool =
    match sel with
      | False -> a
      | True -> b
    end
function mux_gate (a b sel: bool) : bool =
	 let nsel = not_gate sel in
	 let x = nand_gate a nsel in
	 let y = nand_gate b sel in
	 nand_gate x y
lemma mux_gate_correct: forall a b sel: bool. mux_gate a b sel = muxb a b sel

function dmuxb (in_ sel: bool) : (bool, bool) = 
   match sel with
     | False -> (in_, False)
     | True -> (False, in_)
   end
function dmux_gate (in_ sel: bool) : (bool, bool) =
	 let nsel = not_gate sel in
	 let x = and_gate nsel in_ in
	 let y = and_gate sel in_ in
	 (x, y)
lemma dmux_gate_correct: forall in_ sel: bool. dmux_gate in_ sel = dmuxb in_ sel


use import Bit16


clone Bit16Map as Bit16Not with function f = not_gate

use import prelude.Equiv

function not16_gate (a : Bit16.bitv) : Bit16.bitv = Bit16Not.map a
lemma not16_gate_correct_equiv: forall a: Bit16.bitv. not16_gate a == notbv a
lemma not16_gate_correct: forall a: Bit16.bitv. not16_gate a = notbv a


clone Bit16Map2 as Bit16And with function f = and_gate

function and16_gate (a b: Bit16.bitv) : Bit16.bitv = Bit16And.map2 a b
lemma and16_gate_correct_equiv: forall a b: Bit16.bitv. and16_gate a b == andbv a b
lemma and16_gate_correct: forall a b: Bit16.bitv. and16_gate a b = andbv a b 


clone Bit16Map2 as Bit16Or with function f = or_gate

function or16_gate (a b: Bit16.bitv) : Bit16.bitv = Bit16Or.map2 a b
lemma or16_gate_correct_equiv: forall a b: Bit16.bitv. or16_gate a b == orbv a b
lemma or16_gate_correct: forall a b: Bit16.bitv. or16_gate a b = orbv a b 

function mux16b (a b: Bit16.bitv) (sel: bool) : Bit16.bitv =
	 match sel with
	   | False -> a
	   | True -> b
	 end

clone Bit16Map3 as Bit16Mux with function f = mux_gate

function mux16_gate (a b: Bit16.bitv) (sel: bool): Bit16.bitv = Bit16Mux.map3 a b (all sel)
lemma mux16_gate_correct_equiv: forall sel: bool. forall a b: Bit16.bitv. mux16_gate a b sel == mux16b a b sel
lemma mux16_gate_correct: forall sel: bool. forall a b: Bit16.bitv. mux16_gate a b sel = mux16b a b sel

use import Bit8


function or8way_gate (bv: Bit8.bitv) : bool =
	 let x1 = or_gate bv[0] bv[1] in
	 let x2 = or_gate bv[2] bv[3] in
	 let x3 = or_gate bv[4] bv[5] in
	 let x4 = or_gate bv[6] bv[7] in
	 let y1 = or_gate x1 x2 in
	 let y2 = or_gate x3 x4 in
	 or_gate y1 y2

lemma or8way_gate_correct : forall bv: Bit8.bitv.
      or8way_gate bv = orb bv[0] (orb bv[1] (orb bv[2] (orb bv[3] (orb bv[4] (orb bv[5] (orb bv[6] bv[7]))))))

use import Bit2


function mux4way16_gate (a b c d: Bit16.bitv) (sel: Bit2.bitv) : Bit16.bitv =
	 let x1 = mux16_gate a b sel[1] in
	 let x2 = mux16_gate c d sel[1] in
	 mux16_gate x1 x2 sel[0]
	 	 	  

lemma mux4way16_gate_correct: forall a b c d: Bit16.bitv. forall sel: Bit2.bitv.
      		      ((sel[0] = False /\ sel[1] = False) -> mux4way16_gate a b c d sel = a) /\
      		      ((sel[0] = False /\ sel[1] = True) -> mux4way16_gate a b c d sel = b) /\
      		      ((sel[0] = True /\ sel[1] = False) -> mux4way16_gate a b c d sel = c) /\
      		      ((sel[0] = True /\ sel[1] = True) -> mux4way16_gate a b c d sel = d)

(*
use import Bit3

function mux8way16_gate (a b c d e f g h : Bit16.bitv) (sel: Bit3.bitv) : Bit16.bitv =
	 let x1 = mux4way16_gate a b c d (Bit3.zeros[0 <- sel[1]][1 <- sel[2]]) in
	 let x2 = mux4way16_gate e f g h (Bit3.zeros[0 <- sel[1]][1 <- sel[2]]) in
	 mux16_gate x1 x2 sel[0]


lemma mux8way16_gate_correct: forall a b c d e f g h: Bit16.bitv. forall sel: Bit3.bitv.
      		      ((sel[0] = False /\ sel[1] = False /\ sel[2] = False) -> mux8way16_gate a b c d e f g h sel = a) /\
      		      ((sel[0] = False /\ sel[1] = False /\ sel[2] = True) -> mux8way16_gate a b c d e f g h sel = b) /\
      		      ((sel[0] = False /\ sel[1] = True /\ sel[2] = False) -> mux8way16_gate a b c d e f g h sel = c) /\
      		      ((sel[0] = False /\ sel[1] = True /\ sel[2] = True) -> mux8way16_gate a b c d e f g h sel = d) /\
      		      ((sel[0] = True /\ sel[1] = False /\ sel[2] = False) -> mux8way16_gate a b c d e f g h sel = e) /\
      		      ((sel[0] = True /\ sel[1] = False /\ sel[2] = True) -> mux8way16_gate a b c d e f g h sel = f) /\
      		      ((sel[0] = True /\ sel[1] = True /\ sel[2] = False) -> mux8way16_gate a b c d e f g h sel = g) /\
      		      ((sel[0] = True /\ sel[1] = True /\ sel[2] = True) -> mux8way16_gate a b c d e f g h sel = h)
*)
(*
function dmux4way_gate (in_: bool) (sel: Bit2.bitv): (bool, bool, bool, bool) =
	 let x = not_gate sel[0] in
	 let y = not_gate sel[1] in
	 (and_gate in_ (and_gate x y),
	  and_gate in_ (and_gate x sel[1]),
	  and_gate in_ (and_gate sel[0] y),
	  and_gate in_ (and_gate sel[0] sel[1])
	 )

lemma demux4way_gate_correct: forall in_: bool. forall sel: Bit2.bitv.
      		      ((sel[0] = False /\ sel[1] = False) -> dmux4way_gate in_ sel = (in_, False, False, False)) /\
		      ((sel[0] = False /\ sel[1] = True) -> dmux4way_gate in_ sel = (False, in_, False, False)) /\
		      ((sel[0] = True /\ sel[1] = False) -> dmux4way_gate in_ sel = (False, False, in_, False)) /\
		      ((sel[0] = True /\ sel[1] = True) -> dmux4way_gate in_ sel = (False, False, False, in_))

function dmux8way_gate (in_: bool) (sel: Bit3.bitv): (bool, bool, bool, bool, bool, bool, bool, bool) =
	 let x = not_gate sel[0] in
	 let y = not_gate sel[1] in
	 let z = not_gate sel[2] in
	 (and_gate in_ (and_gate x (and_gate y z)),
	  and_gate in_ (and_gate x (and_gate y sel[2])),
	  and_gate in_ (and_gate x (and_gate sel[1] z)),
	  and_gate in_ (and_gate x (and_gate sel[1] sel[2])),
	  and_gate in_ (and_gate sel[0] (and_gate y z)),
	  and_gate in_ (and_gate sel[0] (and_gate y sel[2])),
	  and_gate in_ (and_gate sel[0] (and_gate sel[1] z)),
	  and_gate in_ (and_gate sel[0] (and_gate sel[1] sel[2]))
	 )
	 	 
lemma demux8way_gate_correct: forall in_: bool. forall sel: Bit3.bitv.
      		      ((sel[0] = False /\ sel[1] = False /\ sel[2] = False) -> dmux8way_gate in_ sel = (in_, False, False, False, False, False, False, False)) /\
      		      ((sel[0] = False /\ sel[1] = False /\ sel[2] = True) -> dmux8way_gate in_ sel = (False, in_, False, False, False, False, False, False)) /\
      		      ((sel[0] = False /\ sel[1] = True /\ sel[2] = False) -> dmux8way_gate in_ sel = (False, False, in_, False, False, False, False, False)) /\
      		      ((sel[0] = False /\ sel[1] = True /\ sel[2] = True) -> dmux8way_gate in_ sel = (False, False, False, in_, False, False, False, False)) /\
      		      ((sel[0] = True /\ sel[1] = False /\ sel[2] = False) -> dmux8way_gate in_ sel = (False, False, False, False, in_, False, False, False)) /\
      		      ((sel[0] = True /\ sel[1] = False /\ sel[2] = True) -> dmux8way_gate in_ sel = (False, False, False, False, False, in_, False, False)) /\
      		      ((sel[0] = True /\ sel[1] = True /\ sel[2] = False) -> dmux8way_gate in_ sel = (False, False, False, False, False, False, in_, False)) /\
      		      ((sel[0] = True /\ sel[1] = True /\ sel[2] = True) -> dmux8way_gate in_ sel = (False, False, False, False, False, False, False, in_))

*) 
end

(*
theory Bit1
constant size1: int = 1
clone export BitV with constant size = size1
end

theory Bit17
constant size17: int = 17
clone export BitV with constant size = size17
end


theory Project02

use import Bit1
use import Bit2
use import Bit17
use import int.Int
use import bool.Bool
use import Project01

function halfadder (b1 b2: bool) : Bit2.bitv =
	 zeros[0 <- xor_gate b1 b2]
	      [1 <- and_gate b1 b2]

lemma halfadder_correct: forall b1 b2: bool.
      			 Bit2.to_uint (halfadder b1 b2) = Bit1.to_uint (zeros[0 <- b1]) + Bit1.to_uint (zeros[0 <- b2])

function fulladder (b1 b2 c: bool) : Bit2.bitv =
	 zeros[0 <- xor_gate b1 (xor_gate b2 c)]
	      [1 <- or_gate (and_gate b1 b2) (and_gate c (xor_gate b1 b2))]


lemma fulladder_correct: forall b1 b2 c: bool.
      			 Bit2.to_uint (fulladder b1 b2 c) = Bit1.to_uint (zeros[0 <- b1]) + Bit1.to_uint (zeros[0 <- b2]) + Bit1.to_uint (zeros[0 <- c])

function add16 (b1 b2: Bit16.bitv) : Bit17.bitv =
	 let r0 = halfadder b1[0] b2[0] in
	 let r1 = fulladder b1[1] b2[1] r0[1] in
	 let r2 = fulladder b1[2] b2[2] r1[1] in
	 let r3 = fulladder b1[3] b2[3] r2[1] in
	 let r4 = fulladder b1[4] b2[4] r3[1] in
	 let r5 = fulladder b1[5] b2[5] r4[1] in
	 let r6 = fulladder b1[6] b2[6] r5[1] in
	 let r7 = fulladder b1[7] b2[7] r6[1] in
	 let r8 = fulladder b1[8] b2[8] r7[1] in
	 let r9 = fulladder b1[9] b2[9] r8[1] in
	 let r10 = fulladder b1[10] b2[10] r9[1] in
	 let r11 = fulladder b1[11] b2[11] r10[1] in
	 let r12 = fulladder b1[12] b2[12] r11[1] in
	 let r13 = fulladder b1[13] b2[13] r12[1] in
	 let r14 = fulladder b1[14] b2[14] r13[1] in
	 let r15 = fulladder b1[15] b2[15] r14[1] in
	 zeros[0 <- r0[0]]	 
	      [1 <- r1[0]]
	      [2 <- r2[0]]
	      [3 <- r3[0]]
	      [4 <- r4[0]]
	      [5 <- r5[0]]
	      [6 <- r6[0]]
	      [7 <- r7[0]]
	      [8 <- r8[0]]
	      [9 <- r9[0]]
	      [10 <- r10[0]]
	      [11 <- r11[0]]
	      [12 <- r12[0]]
	      [13 <- r13[0]]
	      [14 <- r14[0]]
	      [15 <- r15[0]]
	      [16 <- r15[1]]



lemma add16_correct: forall b1 b2: Bit16.bitv.
      			 Bit17.to_uint (add16 b1 b2) = Bit16.to_uint b1 + Bit16.to_uint b2

lemma add16_correct2: forall b1 b2: Bit16.bitv.
      			 Bit17.to_sint (add16 b1 b2) = Bit16.to_sint b1 + Bit16.to_sint b2


function incr16 (b1: Bit16.bitv) : Bit17.bitv =
	 add16 b1 (Bit16.zeros[0 <- True])
	 
lemma incr16_correct: forall b1: Bit16.bitv.
      			 Bit17.to_uint (incr16 b1) = Bit16.to_uint b1 + 1

end
*)