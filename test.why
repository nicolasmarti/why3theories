module Test

use int.Int
use int.MinMax
use int.ComputerDivision
use ref.Ref
use array.Array
use real.RealInfix
use real.FromInt
use real.Truncate


val function int2real (i: int) : real
ensures { result = from_int i }


val function real2int (r: real) : int
ensures { result = truncate r }

(*******************)

let left_index (a: array real) (l: int) (u: int) (x: real): int
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
requires { 0 <= l < u < length a /\ a[l] <=. x <. a[u] } 
ensures { 0 <= l <= result < u < length a }
ensures { a[result] <=. x <. a[result+1] }
=
let ref low = l in
let ref high = u in
while low + 1 < high do
variant { high - low }
invariant { 0 <= l <= low <= high <= u < length a }
invariant {low + 1 < high -> a[low] <=. x <. a[high]}
invariant {low + 1 >= high -> a[low] <=. x <. a[low+1]}
let middle = low + div (high - low) 2 in
assert { 0 <= low <= middle <= high < length a };
if a[middle] <=. x then low := middle else high := middle
done;
low

(*******************)

let prepare_positions_left (a: array real): array int
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
ensures { length result = length a }
ensures { forall i.
          0 <= i < length result ->
          a[ result[i] ] <=. a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
          }
ensures { forall i.
          0 <= i < length result ->
          0 <= result[i] < length a
          }
=
let positions = make (length a) 0 in
let step = (a[length a - 1] -. a[0]) /. (int2real (length a - 1)) in
assert { 0.0 <. step  };
let ref index_a = 1 in
let ref index_positions = 1 in

assert{ forall i. 0 <= i < length positions -> a[0] <=. a[0] +. (int2real i) *. step <=. a[length a - 1] };

while index_positions < length positions do
variant { length positions - index_positions }
invariant { forall i.
            0 <= i < index_positions ->
            a[ positions[i] ] <=. a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
          }
invariant{ 1 <= index_a <= length a }
invariant{ 1 <= index_positions <= length positions }
invariant { 
            a[ index_a - 1 ] <=. a[0] +. (from_int index_positions) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
          }
invariant { forall i.
            0 <= i < index_positions ->
            0 <= positions[i] < length a
          }
    
    let v = a[0] +. (int2real index_positions) *. step in
    
    assert{ 0 <= index_positions < length positions };

    while (index_a < length a && a[ index_a ] <=. v ) do
    variant { length a - index_a }
    invariant { 1 <= index_a <= length a }
    invariant { old index_a <= index_a }
    invariant { a[ index_a - 1 ] <=. v }

        assert { (index_a + 1) - 1 = index_a };
        index_a := index_a + 1;
        
        
    done;
    
    positions[ index_positions ] <- index_a - 1;
    index_positions := index_positions + 1;
    

    
done;

positions

(**********)

let prepare_positions_right (a: array real): array int
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
ensures { length result = length a }
ensures { forall i.
          0 <= i < length result ->
          a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1)) <=. a[ result[i] ]
          }
ensures { forall i.
          0 <= i < length result ->
          0 <= result[i] < length a
          }
=
let positions = make (length a) 0 in
let step = (a[length a - 1] -. a[0]) /. (int2real (length a - 1)) in
assert { 0.0 <. step  };
let ref index_a = 1 in
let ref index_positions = 0 in

assert{ forall i. 0 <= i < length positions -> a[0] <=. a[0] +. (int2real i) *. step <=. a[length a - 1] };
assert{ forall i. i = 0 -> a[0] = a[0] +. (int2real i) *. step };


while index_positions < length positions do
variant { length positions - index_positions }
invariant { forall i.
            0 <= i < index_positions ->
            a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1)) <=. a[ positions[i] ]
          }
invariant{ 1 <= index_a <= length a }
invariant{ 0 <= index_positions <= length positions }
invariant{
        a[ index_a - 1 ] <=. a[0] +. (from_int index_positions) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
        }
invariant { forall i.
            0 <= i < index_positions ->
            0 <= positions[i] < length a
          }
    let v = a[0] +. (int2real index_positions) *. step in
    
    assert{ 0 <= index_positions < length positions };

    while (index_a < length a && a[ index_a ] <. v  ) do
    variant { length a - index_a }
    invariant { 1 <= index_a <= length a }
    invariant { old index_a <= index_a }
    invariant { a[ index_a - 1 ] <=. v }

        index_a := index_a + 1;
        
    done;

    assert { v <=. a[ length a - 1] };

    positions[ index_positions ] <- min index_a (length a - 1);
    index_positions := index_positions + 1;
    
    
done;

positions

(******)

let prepare_positions (a: array real) (lows: array int) (highs: array int): real
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
requires { length lows = length a }
requires { length highs = length a }
ensures { result = (a[length a - 1] -. a[0]) /. (from_int (length a - 1)) }
ensures { forall i.
          0 <= i < length lows ->
          a[ lows[i] ] <=. a[0] +. (from_int i) *. result  }
ensures { forall i.
          0 <= i < length highs ->
          a[0] +. (from_int i) *. result <=. a[ highs[i] ]
          }
ensures { forall i.
          0 <= i < length lows ->
          0 <= lows[i] < length a
          }
ensures { forall i.
          0 <= i < length highs ->
          0 <= highs[i] < length a
          }
         
=
let step = (a[length a - 1] -. a[0]) /. (int2real (length a - 1)) in

assert { 0.0 <. step  };

let ref index_lows = 1 in
let ref index_highs = 1 in
let ref index_positions = 0 in

assert{ forall i. 0 <= i < length a -> a[0] <=. a[0] +. (int2real i) *. step <=. a[length a - 1] };
assert{ forall i. i = 0 -> a[0] = a[0] +. (int2real i) *. step };

while index_positions < length a do
variant { length a - index_positions }
invariant{ 1 <= index_lows <= length a }
invariant{ 1 <= index_highs <= length a }
invariant{ 0 <= index_positions <= length a }

invariant { forall i.
            0 <= i < index_positions ->
            a[ lows[i] ] <=. a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
          }
invariant { 
            a[ index_lows - 1 ] <=. a[0] +. (from_int index_positions) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
          }
invariant { forall i.
            0 <= i < index_positions ->
            a[0] +. (from_int i) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1)) <=. a[ highs[i] ]
          }
invariant{
        a[ index_highs - 1 ] <=. a[0] +. (from_int index_positions) *. (a[length a - 1] -. a[0]) /. (from_int (length a - 1))
        }
invariant { forall i.
          0 <= i < index_positions ->
          0 <= lows[i] < length a
          }
invariant { forall i.
          0 <= i < index_positions ->
          0 <= highs[i] < length a
          }

let v = a[0] +. (int2real index_positions) *. step in

assert{ 0 <= index_positions < length a };
    while (index_lows < length a && a[ index_lows ] <=. v ) do
    variant { length a - index_lows }
    invariant { 1 <= index_lows <= length a }
    invariant { a[ index_lows - 1 ] <=. v }

        assert { (index_lows + 1) - 1 = index_lows };
        index_lows := index_lows + 1;
        
        
    done;
lows[ index_positions ] <- index_lows - 1;

    while (index_highs < length a && a[ index_highs ] <. v  ) do
    variant { length a - index_highs }
    invariant { 1 <= index_highs <= length a }
    invariant { a[ index_highs - 1 ] <=. v }

        index_highs := index_highs + 1;
        
    done;

assert { v <=. a[ length highs - 1] };

highs[ index_positions ] <- min index_highs (length a - 1);

index_positions := index_positions + 1;

done;
step

(******)

let prepare_positions2 s(a: array real) (lows: array int) (highs: array int): real
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
requires { length lows = length a }
requires { length highs = length a }
ensures { result = (a[length a - 1] -. a[0]) /. (from_int (length a)) }
ensures { forall i.
          0 <= i < length lows ->
          a[ lows[i] ] <=. a[0] +. (from_int i) *. result  }
ensures { forall i.
          0 <= i < length highs ->
          a[0] +. (from_int i) *. result <. a[ highs[i] ]
          }
ensures { forall i.
          0 <= i < length lows ->
          0 <= lows[i] < length a
          }
ensures { forall i.
          0 <= i < length highs ->
          0 <= highs[i] < length a
          }
         
=
let step = (a[length a - 1] -. a[0]) /. (int2real (length a)) in

assert { 0.0 <. step <. (a[length a - 1] -. a[0]) /. (int2real (length a - 1)) };

let ref index_lows = 1 in
let ref index_highs = 1 in
let ref index_positions = 0 in

assert{ forall i. 0 <= i < length a -> a[0] <=. a[0] +. (int2real i) *. step <. a[length a - 1] };
assert{ forall i. i = 0 -> a[0] = a[0] +. (int2real i) *. step };

while index_positions < length a do
variant { length a - index_positions }
invariant{ 1 <= index_lows <= length a }
invariant{ 1 <= index_highs <= length a }
invariant{ 0 <= index_positions <= length a }

invariant { forall i.
            0 <= i < index_positions ->
            a[ lows[i] ] <=. a[0] +. (from_int i) *. step
          }
invariant { 
            a[ index_lows - 1 ] <=. a[0] +. (from_int index_positions) *. step
          }
invariant { forall i.
            0 <= i < index_positions ->
            a[0] +. (from_int i) *. step <. a[ highs[i] ]
          }
invariant{
        a[ index_highs - 1 ] <=. a[0] +. (from_int index_positions) *. step
        }
invariant { forall i.
          0 <= i < index_positions ->
          0 <= lows[i] < length a
          }
invariant { forall i.
          0 <= i < index_positions ->
          0 <= highs[i] < length a
          }

let v = a[0] +. (int2real index_positions) *. step in

assert{ 0 <= index_positions < length a };
    while (index_lows < length a && a[ index_lows ] <=. v ) do
    variant { length a - index_lows }
    invariant { 1 <= index_lows <= length a }
    invariant { a[ index_lows - 1 ] <=. v }

        assert { (index_lows + 1) - 1 = index_lows };
        index_lows := index_lows + 1;
        
        
    done;
lows[ index_positions ] <- index_lows - 1;

    while (index_highs < length a && a[ index_highs ] <=. v  ) do
    variant { length a - index_highs }
    invariant { 1 <= index_highs <= length a }
    invariant { a[ index_highs - 1 ] <=. v }

        index_highs := index_highs + 1;
        
    done;

assert { v <=. a[ length highs - 1] };

highs[ index_positions ] <- min index_highs (length a - 1);

assert{ a[0] +. (int2real index_positions) *. step <. a[length a - 1] };

index_positions := index_positions + 1;

done;
step

(******)

let prepare_positions3 (a: array real) (lows: array int): real
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
requires { length lows = length a }
ensures { result = (a[length a - 1] -. a[0]) /. (from_int (length a)) }
ensures { forall i.
          0 <= i < length lows ->
          0 <= lows[i] < length a
          }
ensures { forall i.
          0 <= i < length lows ->
          a[ lows[i] ] <=. a[0] +. (from_int i) *. result <. a[ min (lows[i] + 1) (length a - 1) ] }
         
=
let step = (a[length a - 1] -. a[0]) /. (int2real (length a)) in

assert { 0.0 <. step <. (a[length a - 1] -. a[0]) /. (int2real (length a - 1)) };

let ref index_lows = 1 in
let ref index_positions = 0 in

assert{ forall i. 0 <= i < length a -> a[0] <=. a[0] +. (int2real i) *. step <. a[length a - 1] };
assert{ forall i. i = 0 -> a[0] = a[0] +. (int2real i) *. step };

while index_positions < length a do
variant { length a - index_positions }
invariant{ 1 <= index_lows <= length a }
invariant{ 0 <= index_positions <= length a }

invariant { forall i.
          0 <= i < index_positions ->
          0 <= lows[i] < length a
          }
invariant { forall i.
            0 <= i < index_positions ->
            a[ lows[i] ] <=. a[0] +. (from_int i) *. step <. a[ min (lows[i] + 1) (length a - 1) ]
          }
invariant { 
            a[ index_lows - 1 ] <=. a[0] +. (from_int index_positions) *. step
          }

let v = a[0] +. (int2real index_positions) *. step in

assert{ 0 <= index_positions < length a };
    while (index_lows < length a && a[ index_lows ] <=. v ) do
    variant { length a - index_lows }
    invariant { 1 <= index_lows <= length a }
    invariant { a[ index_lows - 1 ] <=. v }

        assert { (index_lows + 1) - 1 = index_lows };
        index_lows := index_lows + 1;
        
        
    done;
lows[ index_positions ] <- index_lows - 1;

assert{ a[0] +. (int2real index_positions) *. step <. a[length a - 1] };

index_positions := index_positions + 1;

done;
step


(********)

let left_index_optim (a: array real) (lows: array int) (highs: array int) (step: real) (x: real): int
requires { length a > 1 }
requires { forall i j. 0 <= i < j <= length a - 1 -> a[i] <. a[j] }
requires { a[0] <. x <. a[length a - 1] }
requires { step = (a[length a - 1] -. a[0]) /. (from_int (length a - 1)) }
requires { length lows = length a }          
requires { length highs = length a }          
requires { forall i.
          0 <= i < length lows ->
          a[ lows[i] ] <=. a[0] +. (from_int i) *. step  }
requires { forall i.
          0 <= i < length highs ->
          a[0] +. (from_int i) *. step <=. a[ highs[i] ]
          }
requires { forall i.
          0 <= i < length lows ->
          0 <= lows[i] < length a
          }
requires { forall i.
          0 <= i < length highs ->
          0 <= highs[i] < length a
          }
ensures { a[result] <=. x <. a[result+1] }
=
let bucket = (x -. a[0]) /. step in
assert { a[0] +. (int2real (real2int bucket)) *. step <=. x = a[0] +. bucket *. step };
let low = lows[ real2int bucket ] in
assert { a[low] <=. x };
let high = highs[ real2int bucket ] in
assert { x <. a[high] };
left_index a low high x

(********)

end

