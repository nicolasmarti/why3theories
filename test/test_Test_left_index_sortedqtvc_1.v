(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length (make n v)) = n).

Parameter truncate: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom Truncate_int :
  forall (i:Numbers.BinNums.Z), ((truncate (BuiltIn.IZR i)) = i).

Axiom Truncate_down_pos :
  forall (x:Reals.Rdefinitions.R), (0%R <= x)%R ->
  ((BuiltIn.IZR (truncate x)) <= x)%R /\
  (x < (BuiltIn.IZR ((truncate x) + 1%Z)%Z))%R.

Axiom Truncate_up_neg :
  forall (x:Reals.Rdefinitions.R), (x <= 0%R)%R ->
  ((BuiltIn.IZR ((truncate x) - 1%Z)%Z) < x)%R /\
  (x <= (BuiltIn.IZR (truncate x)))%R.

Axiom Real_of_truncate :
  forall (x:Reals.Rdefinitions.R),
  ((x - 1%R)%R <= (BuiltIn.IZR (truncate x)))%R /\
  ((BuiltIn.IZR (truncate x)) <= (x + 1%R)%R)%R.

Axiom Truncate_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((truncate x) <= (truncate y))%Z.

Axiom Truncate_monotonic_int1 :
  forall (x:Reals.Rdefinitions.R) (i:Numbers.BinNums.Z),
  (x <= (BuiltIn.IZR i))%R -> ((truncate x) <= i)%Z.

Axiom Truncate_monotonic_int2 :
  forall (x:Reals.Rdefinitions.R) (i:Numbers.BinNums.Z),
  ((BuiltIn.IZR i) <= x)%R -> (i <= (truncate x))%Z.

Parameter floor: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Parameter ceil: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom Floor_int :
  forall (i:Numbers.BinNums.Z), ((floor (BuiltIn.IZR i)) = i).

Axiom Ceil_int : forall (i:Numbers.BinNums.Z), ((ceil (BuiltIn.IZR i)) = i).

Axiom Floor_down :
  forall (x:Reals.Rdefinitions.R),
  ((BuiltIn.IZR (floor x)) <= x)%R /\
  (x < (BuiltIn.IZR ((floor x) + 1%Z)%Z))%R.

Axiom Ceil_up :
  forall (x:Reals.Rdefinitions.R),
  ((BuiltIn.IZR ((ceil x) - 1%Z)%Z) < x)%R /\ (x <= (BuiltIn.IZR (ceil x)))%R.

Axiom Floor_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((floor x) <= (floor y))%Z.

Axiom Ceil_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((ceil x) <= (ceil y))%Z.

Parameter int2real: Numbers.BinNums.Z -> Reals.Rdefinitions.R.

Axiom int2real'spec :
  forall (i:Numbers.BinNums.Z), ((int2real i) = (BuiltIn.IZR i)).

Parameter real2int: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom real2int'spec :
  forall (r:Reals.Rdefinitions.R), ((real2int r) = (truncate r)).

Parameter a: array Reals.Rdefinitions.R.

Parameter x: array Reals.Rdefinitions.R.

Axiom Requires : (1%Z < (length a))%Z.

Axiom Requires1 :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < j)%Z /\ (j < (length a))%Z ->
  ((mixfix_lbrb a i) < (mixfix_lbrb a j))%R.

Axiom Requires2 : (1%Z < (length x))%Z.

Axiom Requires3 :
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length x))%Z ->
  ((mixfix_lbrb a 0%Z) <= (mixfix_lbrb x i))%R /\
  ((mixfix_lbrb x i) < (mixfix_lbrb a ((length a) - 1%Z)%Z))%R.

Axiom Requires4 :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < j)%Z /\ (j < (length a))%Z ->
  ((mixfix_lbrb x i) <= (mixfix_lbrb x j))%R.

Parameter result: array Numbers.BinNums.Z.

Axiom Ensures :
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length x))%Z ->
  ((mixfix_lbrb result i) = 0%Z).

Axiom Ensures1 : ((length result) = (length x)).

Axiom H : (0%Z <= (((length x) - 1%Z)%Z + 1%Z)%Z)%Z.

Parameter index: Numbers.BinNums.Z.

Parameter result1: array Numbers.BinNums.Z.

Axiom H1 : ((length result1) = (length result)).

Parameter i: Numbers.BinNums.Z.

Axiom H2 : (0%Z <= i)%Z.

Axiom H3 : (i <= ((length x) - 1%Z)%Z)%Z.

Axiom H4 : (0%Z < index)%Z.

Axiom H5 : (index < (length a))%Z.

Axiom LoopInvariant :
  forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < i)%Z ->
  (0%Z <= (mixfix_lbrb result1 j))%Z /\
  ((mixfix_lbrb result1 j) < (length a))%Z.

Axiom LoopInvariant1 :
  forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < i)%Z ->
  ((mixfix_lbrb a (mixfix_lbrb result1 j)) <= (mixfix_lbrb x j))%R /\
  ((mixfix_lbrb x j) < (mixfix_lbrb a ((mixfix_lbrb result1 j) + 1%Z)%Z))%R.

Axiom LoopInvariant2 :
  ((mixfix_lbrb a (index - 1%Z)%Z) <=
   (mixfix_lbrb x (ZArith.BinInt.Z.min i ((length x) - 1%Z)%Z)))%R.

Parameter index1: Numbers.BinNums.Z.

Axiom H6 : (1%Z <= index1)%Z.

Axiom H7 : (index1 <= (length a))%Z.

Axiom LoopInvariant3 :
  ((mixfix_lbrb a (index1 - 1%Z)%Z) <= (mixfix_lbrb x i))%R.

Axiom H8 :
  ~ ((index1 < (length a))%Z /\
     ((mixfix_lbrb a index1) <= (mixfix_lbrb x i))%R).

(* Why3 goal *)
Theorem left_index_sorted'vc :
  (((i + 1%Z)%Z <= ((length x) - 1%Z)%Z)%Z ->
   ((mixfix_lbrb x i) <= (mixfix_lbrb x (i + 1%Z)%Z))%R) /\
  (~ ((i + 1%Z)%Z <= ((length x) - 1%Z)%Z)%Z ->
   ((mixfix_lbrb x i) <= (mixfix_lbrb x ((length x) - 1%Z)%Z))%R).
Proof.


Qed.

